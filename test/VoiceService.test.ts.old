import { describe, expect, it, beforeEach, afterEach } from "@effect/vitest"
import { vi } from "vitest"
import { Effect, Layer, Queue } from "effect"
import WS from "ws"
import { VoiceService, VoiceServiceLive } from "../src/services/VoiceService.js"
import type { RealtimeEvent } from "../src/domain.js"

vi.mock("ws", () => {
  const mockWebSocket = {
    on: vi.fn(),
    send: vi.fn(),
    close: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    readyState: 1,
  }

  return {
    default: vi.fn(() => mockWebSocket),
  }
})

const WebSocketConstructor = WS as unknown as ReturnType<typeof vi.fn>

describe("VoiceService", () => {
  const originalEnv = process.env.OPENAI_API_KEY

  beforeEach(() => {
    vi.clearAllMocks()
    process.env.OPENAI_API_KEY = "test-api-key"
  })

  afterEach(() => {
    process.env.OPENAI_API_KEY = originalEnv
  })

  describe("WebSocket Connection Lifecycle", () => {
    it.effect("should create WebSocket with correct URL and headers", () =>
      Effect.gen(function* () {
        let openCallback: (() => void) | undefined
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              openCallback = callback
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const setupEffect = Layer.launch(VoiceServiceLive).pipe(Effect.fork)
        const fiber = yield* setupEffect

        yield* Effect.sleep("10 millis")

        if (openCallback) {
          openCallback()
        }

        yield* Effect.sleep("10 millis")

        expect(WebSocketConstructor).toHaveBeenCalledWith(
          "wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-10-01",
          {
            headers: {
              Authorization: "Bearer test-api-key",
              "OpenAI-Beta": "realtime=v1",
            },
          }
        )

        yield* fiber.interruptFork
      })
    )

    it.effect("should handle connection errors", () =>
      Effect.gen(function* () {
        let errorCallback: ((error: Error) => void) | undefined
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "error") {
              errorCallback = callback
              setTimeout(() => {
                if (errorCallback) {
                  errorCallback(new Error("Connection failed"))
                }
              }, 5)
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const result = yield* Effect.either(Layer.launch(VoiceServiceLive))

        expect(result._tag).toBe("Left")
        if (result._tag === "Left") {
          expect(result.left.message).toContain("WebSocket connection failed")
        }
      })
    )

    it.effect("should close WebSocket on cleanup", () =>
      Effect.gen(function* () {
        let openCallback: (() => void) | undefined
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              openCallback = callback
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const scope = yield* Effect.scope

        const setupEffect = Layer.buildWithScope(VoiceServiceLive, scope).pipe(
          Effect.flatMap(() => Effect.unit)
        )

        const fiber = yield* Effect.fork(setupEffect)

        yield* Effect.sleep("10 millis")

        if (openCallback) {
          openCallback()
        }

        yield* Effect.sleep("10 millis")

        yield* Effect.addFinalizer(() =>
          Effect.sync(() => {
            expect(mockWebSocket.close).toHaveBeenCalled()
          })
        )

        yield* fiber.interrupt
      })
    )

    it.effect("should handle missing OPENAI_API_KEY", () =>
      Effect.gen(function* () {
        delete process.env.OPENAI_API_KEY

        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Layer.launch(VoiceServiceLive)
        const result = yield* Effect.either(program)

        expect(result._tag).toBe("Right")

        expect(WebSocketConstructor).toHaveBeenCalledWith(
          expect.any(String),
          expect.objectContaining({
            headers: expect.objectContaining({
              Authorization: "Bearer undefined",
            }),
          })
        )
      })
    )
  })

  describe("Event Handling", () => {
    it.effect("should queue incoming WebSocket messages", () =>
      Effect.gen(function* () {
        let messageCallback: ((data: Buffer) => void) | undefined
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            if (event === "message") {
              messageCallback = callback
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          const testEvent: RealtimeEvent = {
            type: "session.update",
            session: { instructions: "test" },
          }

          if (messageCallback) {
            messageCallback(Buffer.from(JSON.stringify(testEvent)))
          }

          yield* Effect.sleep("10 millis")

          const received = yield* Queue.take(service.eventStream)

          expect(received).toEqual(testEvent)
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )

    it.effect("should queue multiple events in order", () =>
      Effect.gen(function* () {
        let messageCallback: ((data: Buffer) => void) | undefined
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            if (event === "message") {
              messageCallback = callback
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          const events: RealtimeEvent[] = [
            { type: "session.update", session: { instructions: "event1" } },
            { type: "response.create" },
            {
              type: "conversation.item.create",
              item: { type: "function_call_output", call_id: "123", output: "test" },
            },
          ]

          if (messageCallback) {
            events.forEach((event) => {
              messageCallback(Buffer.from(JSON.stringify(event)))
            })
          }

          yield* Effect.sleep("10 millis")

          const received1 = yield* Queue.take(service.eventStream)
          const received2 = yield* Queue.take(service.eventStream)
          const received3 = yield* Queue.take(service.eventStream)

          expect(received1).toEqual(events[0])
          expect(received2).toEqual(events[1])
          expect(received3).toEqual(events[2])
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )

    it.effect("should handle malformed JSON gracefully", () =>
      Effect.gen(function* () {
        let messageCallback: ((data: Buffer) => void) | undefined
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            if (event === "message") {
              messageCallback = callback
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          if (messageCallback) {
            expect(() => {
              messageCallback(Buffer.from("invalid json"))
            }).toThrow()
          }

          const isEmpty = yield* Queue.isEmpty(service.eventStream)
          expect(isEmpty).toBe(true)
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )

    it.effect("should handle WebSocket errors", () =>
      Effect.gen(function* () {
        let errorCallback: ((error: Error) => void) | undefined
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            if (event === "error") {
              errorCallback = callback
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          yield* VoiceService
          yield* Effect.sleep("20 millis")

          if (errorCallback) {
            errorCallback(new Error("WebSocket runtime error"))
          }

          yield* Effect.sleep("10 millis")
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )
  })

  describe("Send Operations", () => {
    it.effect("should send events through WebSocket", () =>
      Effect.gen(function* () {
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          const testEvent: RealtimeEvent = {
            type: "response.create",
          }

          yield* service.send(testEvent)

          expect(mockWebSocket.send).toHaveBeenCalledWith(JSON.stringify(testEvent))
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )

    it.effect("should send complex events with all fields", () =>
      Effect.gen(function* () {
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          const testEvent: RealtimeEvent = {
            type: "session.update",
            session: {
              instructions: "You are a helpful assistant",
              tools: [
                {
                  type: "function",
                  name: "test_function",
                  description: "A test function",
                  parameters: {
                    type: "object",
                    properties: { test: { type: "string" } },
                    required: ["test"],
                  },
                },
              ],
              voice: "alloy",
              input_audio_format: "pcm16",
              output_audio_format: "pcm16",
            },
          }

          yield* service.send(testEvent)

          expect(mockWebSocket.send).toHaveBeenCalledWith(JSON.stringify(testEvent))
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )

    it.effect("should handle send errors", () =>
      Effect.gen(function* () {
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            return mockWebSocket
          }),
          send: vi.fn(() => {
            throw new Error("Send failed")
          }),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          const testEvent: RealtimeEvent = { type: "response.create" }

          const result = yield* Effect.either(service.send(testEvent))

          expect(result._tag).toBe("Left")
          if (result._tag === "Left") {
            expect(result.left.message).toContain("Failed to send event")
          }
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )

    it.effect("should send multiple events sequentially", () =>
      Effect.gen(function* () {
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          const events: RealtimeEvent[] = [
            { type: "session.update", session: { instructions: "test1" } },
            { type: "response.create" },
            {
              type: "conversation.item.create",
              item: { type: "function_call_output", call_id: "456", output: "result" },
            },
          ]

          yield* Effect.forEach(events, (event) => service.send(event), {
            concurrency: 1,
          })

          expect(mockWebSocket.send).toHaveBeenCalledTimes(3)
          events.forEach((event, index) => {
            expect(mockWebSocket.send).toHaveBeenNthCalledWith(
              index + 1,
              JSON.stringify(event)
            )
          })
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )
  })

  describe("Queue Operations", () => {
    it.effect("should create unbounded queue for eventStream", () =>
      Effect.gen(function* () {
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          const isEmpty = yield* Queue.isEmpty(service.eventStream)
          expect(isEmpty).toBe(true)

          const size = yield* Queue.size(service.eventStream)
          expect(size).toBe(0)
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )

    it.effect("should handle queue operations without blocking", () =>
      Effect.gen(function* () {
        let messageCallback: ((data: Buffer) => void) | undefined
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            if (event === "message") {
              messageCallback = callback
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          const events = Array.from({ length: 100 }, (_, i) => ({
            type: "session.update" as const,
            session: { instructions: `event${i}` },
          }))

          if (messageCallback) {
            events.forEach((event) => {
              messageCallback(Buffer.from(JSON.stringify(event)))
            })
          }

          yield* Effect.sleep("20 millis")

          const size = yield* Queue.size(service.eventStream)
          expect(size).toBe(100)

          const receivedEvents: RealtimeEvent[] = []
          for (let i = 0; i < 100; i++) {
            const event = yield* Queue.take(service.eventStream)
            receivedEvents.push(event)
          }

          expect(receivedEvents).toHaveLength(100)
          expect(receivedEvents[0]).toEqual(events[0])
          expect(receivedEvents[99]).toEqual(events[99])
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )
  })

  describe("Layer Lifecycle", () => {
    it.effect("should provide VoiceService through Layer", () =>
      Effect.gen(function* () {
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          expect(service).toBeDefined()
          expect(service.connect).toBeDefined()
          expect(service.eventStream).toBeDefined()
          expect(service.send).toBeDefined()
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )

    it.effect("should handle multiple Layer instances independently", () =>
      Effect.gen(function* () {
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program1 = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")
          return service
        }).pipe(Effect.provide(VoiceServiceLive))

        const program2 = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")
          return service
        }).pipe(Effect.provide(VoiceServiceLive))

        const [service1, service2] = yield* Effect.all([program1, program2], {
          concurrency: 2,
        })

        expect(service1).toBeDefined()
        expect(service2).toBeDefined()
        expect(WebSocketConstructor).toHaveBeenCalledTimes(2)
      })
    )

    it.effect("should execute connect effect", () =>
      Effect.gen(function* () {
        const mockWebSocket = {
          on: vi.fn((event: string, callback: any) => {
            if (event === "open") {
              setTimeout(() => callback(), 5)
            }
            return mockWebSocket
          }),
          send: vi.fn(),
          close: vi.fn(),
          addEventListener: vi.fn(),
          removeEventListener: vi.fn(),
          readyState: 1,
        }

        WebSocketConstructor.mockReturnValue(mockWebSocket)

        const program = Effect.gen(function* () {
          const service = yield* VoiceService
          yield* Effect.sleep("20 millis")

          const result = yield* Effect.either(service.connect)

          expect(result._tag).toBe("Right")
        })

        yield* program.pipe(Effect.provide(VoiceServiceLive))
      })
    )
  })
})
